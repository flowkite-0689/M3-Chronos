# 统一菜单框架使用指南

## 概述

统一菜单框架是一个用于STM32项目的灵活菜单系统，支持两种主要菜单类型：
- **横向图标菜单**：适用于主菜单界面，以图标形式展示菜单项
- **竖向列表菜单**：适用于设置和测试菜单，以文本列表形式展示菜单项

框架基于FreeRTOS实现，提供了完整的菜单创建、导航、事件处理和显示功能。

## 框架特点

1. **统一的架构**：一套API支持横向图标和竖向列表两种菜单类型
2. **灵活的布局**：可自定义菜单项位置、大小、间距等布局参数
3. **事件驱动**：基于FreeRTOS队列的事件处理机制
4. **分层结构**：支持多级菜单嵌套
5. **回调机制**：提供菜单生命周期回调函数
6. **自定义页面**：支持完全自定义的绘制和交互

## 快速开始

### 1. 初始化菜单系统

```c
#include "unified_menu.h"

int main(void)
{
    // 初始化硬件和外设...
    
    // 初始化菜单系统
    if (menu_system_init() != 0) {
        printf("Menu system initialization failed\r\n");
        return -1;
    }
    
    // 创建菜单任务
    xTaskCreate(menu_task, "MenuTask", 256, NULL, 3, NULL);
    xTaskCreate(menu_key_task, "KeyTask", 128, NULL, 4, NULL);
    
    // 启动调度器
    vTaskStartScheduler();
    
    return 0;
}
```

### 2. 创建主菜单

```c
// 创建主菜单（横向图标菜单）
menu_item_t* main_menu = menu_item_create(
    "Main Menu",
    MENU_TYPE_HORIZONTAL_ICON,
    (menu_content_t){0}  // 主菜单通常不需要内容
);

// 设置主菜单为根菜单
g_menu_sys.root_menu = main_menu;
g_menu_sys.current_menu = main_menu;
```

## 使用模板创建菜单项

### 创建图标菜单项（横向菜单）

```c
// 假设已有图标数据
extern const unsigned char icon_clock[];
extern const unsigned char icon_settings[];
extern const unsigned char icon_test[];

// 创建时钟功能菜单项
menu_item_t* clock_menu = MENU_ITEM_ICON("Clock", icon_clock, 32, 32);
menu_add_child(main_menu, clock_menu);

// 创建设置功能菜单项
menu_item_t* settings_menu = MENU_ITEM_ICON("Settings", icon_settings, 32, 32);
menu_add_child(main_menu, settings_menu);

// 创建测试功能菜单项
menu_item_t* test_menu = MENU_ITEM_ICON("Test", icon_test, 32, 32);
menu_add_child(main_menu, test_menu);
```

### 创建文本菜单项（竖向菜单）

```c
// 创建设置菜单（竖向列表菜单）
menu_item_t* settings_menu = menu_item_create(
    "Settings Menu",
    MENU_TYPE_VERTICAL_LIST,
    (menu_content_t){0}
);

// 创建设置子菜单项
menu_item_t* time_setting = MENU_ITEM_TEXT("Time", "Time Setting", 12);
menu_add_child(settings_menu, time_setting);

menu_item_t* date_setting = MENU_ITEM_TEXT("Date", "Date Setting", 12);
menu_add_child(settings_menu, date_setting);

menu_item_t* display_setting = MENU_ITEM_TEXT("Display", "Display Setting", 15);
menu_add_child(settings_menu, display_setting);

// 将设置菜单添加到主菜单
menu_add_child(main_menu, settings_menu);
```

## 设置菜单项位置和布局

### 横向菜单布局配置

```c
// 使用预设布局
g_menu_sys.layout = (menu_layout_config_t)LAYOUT_HORIZONTAL_MAIN();

// 或者自定义布局
g_menu_sys.layout.horizontal.visible_count = 3;  // 显示3个图标
g_menu_sys.layout.horizontal.item_width = 32;     // 图标宽度
g_menu_sys.layout.horizontal.item_height = 32;    // 图标高度
g_menu_sys.layout.horizontal.spacing = 16;       // 图标间距
g_menu_sys.layout.horizontal.start_x = 0;         // 起始X坐标
g_menu_sys.layout.horizontal.start_y = 16;        // 起始Y坐标
```

### 竖向菜单布局配置

```c
// 使用预设布局
g_menu_sys.layout = (menu_layout_config_t)LAYOUT_VERTICAL_TEST();

// 或者自定义布局
g_menu_sys.layout.vertical.items_per_page = 4;    // 每页显示4项
g_menu_sys.layout.vertical.item_height = 16;      // 项目高度
g_menu_sys.layout.vertical.start_x = 0;           // 起始X坐标
g_menu_sys.layout.vertical.start_y = 0;           // 起始Y坐标
g_menu_sys.layout.vertical.indent_spaces = 2;     // 缩进空格数
g_menu_sys.layout.vertical.selected_char = '>';   // 选中字符
g_menu_sys.layout.vertical.unselected_char = ' '; // 未选中字符
```

## 设置菜单项回调函数

```c
// 定义回调函数
void on_clock_enter(menu_item_t* item)
{
    printf("Enter clock function\r\n");
    // 进入时钟功能的逻辑
}

void on_settings_select(menu_item_t* item)
{
    printf("Settings selected\r\n");
    // 设置菜单被选中时的逻辑
}

void on_test_key(menu_item_t* item, uint8_t key_event)
{
    printf("Test menu key event: %d\r\n", key_event);
    // 自定义按键处理逻辑
}

// 设置回调函数
menu_item_set_callbacks(clock_menu, on_clock_enter, NULL, NULL, NULL);
menu_item_set_callbacks(settings_menu, NULL, NULL, on_settings_select, NULL);
menu_item_set_callbacks(test_menu, NULL, NULL, NULL, on_test_key);
```

## 菜单导航控制

### 程序化控制菜单导航

```c
// 进入指定菜单
menu_enter(settings_menu);

// 返回父菜单
menu_back_to_parent();

// 选择下一个菜单项
menu_select_next();

// 选择上一个菜单项
menu_select_previous();

// 进入选中的菜单项
menu_enter_selected();
```

## 使用自定义页面

### 创建自定义绘制菜单

```c
// 自定义绘制函数
void draw_custom_page(void* context)
{
    // 获取自定义数据
    custom_data_t* data = (custom_data_t*)context;
    
    // 清屏
    OLED_Clear();
    
    // 绘制自定义内容
    OLED_Printf_Line(0, "Custom Page");
    OLED_Printf_Line(1, "Value: %d", data->value);
    OLED_Printf_Line(2, "Status: %s", data->status ? "ON" : "OFF");
    
    // 绘制进度条
    for (int i = 0; i < data->progress; i++) {
        OLED_DrawPixel(i, 40, 1);
    }
    
    // 刷新显示
    OLED_Refresh();
}

// 创建自定义数据
typedef struct {
    int value;
    uint8_t status;
    uint8_t progress;
} custom_data_t;

custom_data_t my_custom_data = {
    .value = 42,
    .status = 1,
    .progress = 80
};

// 创建自定义菜单项
menu_item_t* custom_menu = menu_item_create(
    "Custom Page",
    MENU_TYPE_VERTICAL_LIST,  // 类型可以是任意，主要使用自定义绘制
    (menu_content_t){
        .custom = {
            .draw_function = draw_custom_page,
            .draw_context = &my_custom_data
        }
    }
);

// 设置自定义菜单的回调
void on_custom_key(menu_item_t* item, uint8_t key_event)
{
    custom_data_t* data = (custom_data_t*)item->content.custom.draw_context;
    
    switch (key_event) {
        case MENU_EVENT_KEY_UP:
            data->value++;
            break;
        case MENU_EVENT_KEY_DOWN:
            data->value--;
            break;
        case MENU_EVENT_KEY_ENTER:
            data->status = !data->status;
            break;
        case MENU_EVENT_KEY_SELECT:
            menu_back_to_parent();
            break;
    }
    
    // 触发刷新
    g_menu_sys.need_refresh = 1;
}

menu_item_set_callbacks(custom_menu, NULL, NULL, NULL, on_custom_key);
```

### 在显示函数中处理自定义页面

```c
// 修改menu_refresh_display函数以支持自定义页面
void menu_refresh_display_custom(void)
{
    if (g_menu_sys.current_menu == NULL) {
        return;
    }
    
    if (xSemaphoreTake(g_menu_sys.display_mutex, pdMS_TO_TICKS(50)) != pdTRUE) {
        return;
    }
    
    // 检查是否是自定义页面
    if (g_menu_sys.current_menu->content.custom.draw_function) {
        g_menu_sys.current_menu->content.custom.draw_function(
            g_menu_sys.current_menu->content.custom.draw_context
        );
    } else {
        // 原有的显示逻辑
        switch (g_menu_sys.current_menu->type) {
            case MENU_TYPE_HORIZONTAL_ICON:
                menu_display_horizontal(g_menu_sys.current_menu);
                break;
            case MENU_TYPE_VERTICAL_LIST:
                menu_display_vertical(g_menu_sys.current_menu);
                break;
        }
    }
    
    g_menu_sys.last_refresh_time = xTaskGetTickCount();
    g_menu_sys.need_refresh = 0;
    
    xSemaphoreGive(g_menu_sys.display_mutex);
}
```

## 事件处理

### 按键映射

系统自动将硬件按键映射为菜单事件：

- **KEY0**: MENU_EVENT_KEY_UP (上/左)
- **KEY1**: MENU_EVENT_KEY_DOWN (下/右)
- **KEY2**: MENU_EVENT_KEY_SELECT (选择/返回)
- **KEY3**: MENU_EVENT_KEY_ENTER (确认/进入)

### 自定义事件处理

```c
// 在菜单项的按键回调中处理特定事件
void custom_key_handler(menu_item_t* item, uint8_t key_event)
{
    switch (key_event) {
        case MENU_EVENT_KEY_UP:
            // 处理向上键
            break;
        case MENU_EVENT_KEY_DOWN:
            // 处理向下键
            break;
        case MENU_EVENT_KEY_ENTER:
            // 处理确认键
            break;
        case MENU_EVENT_KEY_SELECT:
            // 处理选择键
            break;
        case MENU_EVENT_REFRESH:
            // 处理刷新事件
            break;
    }
}
```

### 发送自定义事件

```c
// 发送刷新事件
menu_event_t refresh_event = {
    .type = MENU_EVENT_REFRESH,
    .timestamp = xTaskGetTickCount(),
    .param = 0
};
xQueueSend(g_menu_sys.event_queue, &refresh_event, 0);

// 发送闹钟事件
menu_event_t alarm_event = {
    .type = MENU_EVENT_ALARM,
    .timestamp = xTaskGetTickCount(),
    .param = 1  // 闹钟ID
};
xQueueSend(g_menu_sys.event_queue, &alarm_event, 0);
```

## 完整示例

### 示例：创建一个完整的菜单系统

```c
#include "unified_menu.h"
#include "icons.h"  // 假设的图标头文件

// 图标数据声明
extern const unsigned char icon_clock[];
extern const unsigned char icon_settings[];
extern const unsigned char icon_test[];

// 回调函数实现
void on_clock_enter(menu_item_t* item)
{
    // 创建时钟显示页面
    menu_item_t* clock_page = menu_item_create(
        "Clock Display",
        MENU_TYPE_VERTICAL_LIST,
        (menu_content_t){
            .custom = {
                .draw_function = draw_clock_display,
                .draw_context = NULL
            }
        }
    );
    
    menu_item_set_callbacks(clock_page, NULL, NULL, NULL, on_clock_key);
    menu_enter(clock_page);
}

void on_clock_key(menu_item_t* item, uint8_t key_event)
{
    if (key_event == MENU_EVENT_KEY_SELECT) {
        menu_back_to_parent();
    }
}

void draw_clock_display(void* context)
{
    // 获取当前时间（假设有RTC获取函数）
    rtc_time_t time = RTC_GetTime();
    
    OLED_Clear();
    OLED_Printf_Line(0, "Current Time");
    OLED_Printf_Line(2, "%02d:%02d:%02d", 
                     time.hours, time.minutes, time.seconds);
    OLED_Printf_Line(4, "%02d/%02d/%04d", 
                     time.day, time.month, time.year);
    OLED_Refresh();
}

// 创建完整菜单系统
void create_menu_system(void)
{
    // 创建主菜单
    menu_item_t* main_menu = menu_item_create(
        "Main Menu",
        MENU_TYPE_HORIZONTAL_ICON,
        (menu_content_t){0}
    );
    
    // 创建功能菜单项
    menu_item_t* clock_menu = MENU_ITEM_ICON("Clock", icon_clock, 32, 32);
    menu_item_t* settings_menu = MENU_ITEM_ICON("Settings", icon_settings, 32, 32);
    menu_item_t* test_menu = MENU_ITEM_ICON("Test", icon_test, 32, 32);
    
    // 设置回调
    menu_item_set_callbacks(clock_menu, on_clock_enter, NULL, NULL, NULL);
    
    // 创建设置子菜单
    menu_item_t* time_setting = MENU_ITEM_TEXT("Time", "Time Setting", 12);
    menu_item_t* date_setting = MENU_ITEM_TEXT("Date", "Date Setting", 12);
    menu_item_t* display_setting = MENU_ITEM_TEXT("Display", "Display Setting", 15);
    
    menu_add_child(settings_menu, time_setting);
    menu_add_child(settings_menu, date_setting);
    menu_add_child(settings_menu, display_setting);
    
    // 添加到主菜单
    menu_add_child(main_menu, clock_menu);
    menu_add_child(main_menu, settings_menu);
    menu_add_child(main_menu, test_menu);
    
    // 设置根菜单和当前菜单
    g_menu_sys.root_menu = main_menu;
    g_menu_sys.current_menu = main_menu;
    
    // 设置布局
    g_menu_sys.layout = (menu_layout_config_t)LAYOUT_HORIZONTAL_MAIN();
}

// 主函数
int main(void)
{
    // 硬件初始化...
    
    // 初始化菜单系统
    menu_system_init();
    
    // 创建菜单结构
    create_menu_system();
    
    // 创建任务
    xTaskCreate(menu_task, "MenuTask", 256, NULL, 3, NULL);
    xTaskCreate(menu_key_task, "KeyTask", 128, NULL, 4, NULL);
    
    // 启动调度器
    vTaskStartScheduler();
    
    return 0;
}
```

## API参考

### 核心API

| 函数名 | 描述 |
|--------|------|
| `menu_system_init()` | 初始化菜单系统 |
| `menu_item_create()` | 创建菜单项 |
| `menu_add_child()` | 添加子菜单项 |
| `menu_item_set_position()` | 设置菜单项位置 |
| `menu_item_set_callbacks()` | 设置回调函数 |
| `menu_enter()` | 进入指定菜单 |
| `menu_back_to_parent()` | 返回父菜单 |
| `menu_select_next()` | 选择下一个菜单项 |
| `menu_select_previous()` | 选择上一个菜单项 |
| `menu_enter_selected()` | 进入选中的菜单项 |
| `menu_refresh_display()` | 刷新菜单显示 |

### 便利宏

| 宏名 | 描述 |
|------|------|
| `MENU_ITEM_ICON()` | 创建图标菜单项 |
| `MENU_ITEM_TEXT()` | 创建文本菜单项 |
| `LAYOUT_HORIZONTAL_MAIN()` | 横向主菜单布局预设 |
| `LAYOUT_VERTICAL_TEST()` | 竖向测试菜单布局预设 |

### 数据结构

- `menu_item_t`: 菜单项结构体
- `menu_system_t`: 菜单系统结构体
- `menu_event_t`: 菜单事件结构体
- `menu_layout_config_t`: 菜单布局配置结构体

## 注意事项

1. **内存管理**：菜单项使用动态内存分配，确保系统有足够的堆空间
2. **线程安全**：显示函数使用互斥量保护，确保多任务环境下的安全访问
3. **按键去抖**：系统内置按键去抖机制，默认去抖时间为500ms
4. **刷新频率**：显示刷新频率为100ms，可根据需要调整
5. **任务优先级**：建议按键任务优先级高于菜单任务，确保及时响应

## 故障排除

### 常见问题

1. **菜单不显示**
   - 检查菜单系统是否正确初始化
   - 确认OLED显示是否正常工作
   - 检查是否正确设置了当前菜单

2. **按键无响应**
   - 检查按键任务是否创建并运行
   - 确认按键硬件驱动是否正常
   - 检查事件队列是否正确创建

3. **显示异常**
   - 检查布局配置是否正确
   - 确认菜单项位置是否在显示范围内
   - 检查是否正确刷新显示

4. **内存不足**
   - 检查FreeRTOS堆大小配置
   - 考虑使用静态分配代替动态分配
   - 优化菜单项数量和层级深度

通过以上指南，您应该能够快速掌握并使用统一菜单框架来构建各种类型的用户界面。如果遇到更复杂的需求，可以参考API文档或源代码实现更高级的功能。