# 统一菜单框架使用指南

## 目录
1. [项目结构](#项目结构)
2. [概述](#概述)
3. [框架特点](#框架特点)
4. [快速开始](#快速开始)
5. [使用模板创建菜单项](#使用模板创建菜单项)
6. [创建自定义菜单页面](#创建自定义菜单页面)
7. [项目集成指南](#项目集成指南)
8. [API参考](#api参考)
9. [完整示例](#完整示例)
10. [注意事项](#注意事项)
11. [故障排除](#故障排除)

## 项目结构

### 推荐的项目文件组织结构

```
M3-Chronos/
├── User/
│   ├── ui/
│   │   ├── Inc/
│   │   │   ├── unified_menu.h      // 统一菜单框架头文件
│   │   │   ├── index.h           // 首页头文件（示例）
│   │   │   ├── clock_menu.h      // 时钟菜单头文件（示例）
│   │   │   └── settings_menu.h   // 设置菜单头文件（示例）
│   │   └── Src/
│   │       ├── unified_menu.c      // 统一菜单框架实现
│   │       ├── index.c           // 首页实现（示例）
│   │       ├── clock_menu.c      // 时钟菜单实现（示例）
│   │       └── settings_menu.c   // 设置菜单实现（示例）
│   ├── icons/                     // 图标资源目录
│   │   ├── icon_clock.h
│   │   ├── icon_settings.h
│   │   └── icon_test.h
│   └── main.c                    // 主程序文件
```

### 文件创建说明

1. **菜单页面文件**：应该在 `User/ui/` 目录下创建
   - 头文件放在 `Inc/` 子目录
   - 实现文件放在 `Src/` 子目录
   - 建议每个菜单页面一个文件对（.h 和 .c）

2. **图标资源文件**：应该在 `User/icons/` 目录下创建
   - 每个图标一个头文件
   - 包含图标的字节数组数据

## 概述

统一菜单框架是一个用于STM32项目的灵活菜单系统，支持三种主要菜单类型：
- **横向图标菜单**：适用于主菜单界面，以图标形式展示菜单项
- **竖向列表菜单**：适用于设置和测试菜单，以文本列表形式展示菜单项
- **自定义页面**：完全自定义绘制和交互的页面（如首页、时钟页面等）

框架基于FreeRTOS实现，提供了完整的菜单创建、导航、事件处理和显示功能。

## 框架特点

1. **统一的架构**：一套API支持多种菜单类型
2. **灵活的布局**：可自定义菜单项位置、大小、间距等布局参数
3. **事件驱动**：基于FreeRTOS队列的事件处理机制
4. **分层结构**：支持多级菜单嵌套
5. **回调机制**：提供菜单生命周期回调函数
6. **自定义页面**：支持完全自定义的绘制和交互
7. **内存效率**：针对小内存单片机优化设计

## 快速开始

### 1. 添加框架文件

首先将统一菜单框架文件添加到项目中：
- `User/ui/Inc/unified_menu.h`
- `User/ui/Src/unified_menu.c`

### 2. 初始化菜单系统

```c
#include "unified_menu.h"

int main(void)
{
    // 初始化硬件和外设...
    TIM2_Delay_Init();
    debug_init();
    OLED_Init();
    Key_Init();
    
    // 初始化菜单系统
    if (menu_system_init() != 0) {
        printf("Menu system initialization failed\r\n");
        return -1;
    }
    
    // 创建菜单结构
    create_menu_system();
    
    // 创建菜单任务
    xTaskCreate(menu_task, "MenuTask", 256, NULL, 3, NULL);
    xTaskCreate(menu_key_task, "KeyTask", 128, NULL, 4, NULL);
    
    // 启动调度器
    vTaskStartScheduler();
    
    return 0;
}
```

### 3. 创建根菜单

```c
// 在 User/ui/Src/main_menu.c 中创建
#include "unified_menu.h"

menu_item_t* main_menu_init(void)
{
    // 创建主菜单（横向图标菜单）
    menu_item_t* main_menu = menu_item_create(
        "Main Menu",
        MENU_TYPE_HORIZONTAL_ICON,
        (menu_content_t){0}  // 主菜单通常不需要内容
    );
    
    // 设置主菜单为根菜单
    g_menu_sys.root_menu = main_menu;
    g_menu_sys.current_menu = main_menu;
    
    return main_menu;
}

void create_menu_system(void)
{
    // 创建根菜单
    menu_item_t* main_menu = main_menu_init();
    
    // 创建并添加子菜单项
    create_clock_menu(main_menu);
    create_settings_menu(main_menu);
    create_test_menu(main_menu);
    
    // 设置布局
    g_menu_sys.layout = (menu_layout_config_t)LAYOUT_HORIZONTAL_MAIN();
}
```

## 使用模板创建菜单项

### 创建图标资源文件

1. **在 `User/icons/` 目录下创建图标文件**

例如 `User/icons/icon_clock.h`：
```c
#ifndef __ICON_CLOCK_H
#define __ICON_CLOCK_H

#include <stdint.h>

const unsigned char icon_clock[] = {
    // 32x32 图标数据
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    // ... 更多数据
};

#define ICON_CLOCK_WIDTH  32
#define ICON_CLOCK_HEIGHT 32

#endif // __ICON_CLOCK_H
```

### 创建图标菜单项（横向菜单）

1. **在 `User/ui/Src/clock_menu.c` 中创建**

```c
#include "clock_menu.h"
#include "unified_menu.h"
#include "../icons/icon_clock.h"

menu_item_t* create_clock_menu(menu_item_t* parent)
{
    // 创建时钟功能菜单项
    menu_item_t* clock_menu = MENU_ITEM_ICON(
        "Clock", 
        icon_clock, 
        ICON_CLOCK_WIDTH, 
        ICON_CLOCK_HEIGHT
    );
    
    // 设置回调函数
    menu_item_set_callbacks(clock_menu, on_clock_enter, NULL, NULL, NULL);
    
    // 添加到父菜单
    menu_add_child(parent, clock_menu);
    
    return clock_menu;
}

void on_clock_enter(menu_item_t* item)
{
    // 创建时钟显示页面
    menu_item_t* clock_page = menu_item_create(
        "Clock Display",
        MENU_TYPE_CUSTOM,
        (menu_content_t){
            .custom = {
                .draw_function = draw_clock_display,
                .draw_context = NULL
            }
        }
    );
    
    menu_item_set_callbacks(clock_page, NULL, NULL, NULL, on_clock_key);
    menu_enter(clock_page);
}
```

### 创建文本菜单项（竖向菜单）

1. **在 `User/ui/Src/settings_menu.c` 中创建**

```c
#include "settings_menu.h"
#include "unified_menu.h"

menu_item_t* create_settings_menu(menu_item_t* parent)
{
    // 创建设置菜单（竖向列表菜单）
    menu_item_t* settings_menu = menu_item_create(
        "Settings Menu",
        MENU_TYPE_VERTICAL_LIST,
        (menu_content_t){0}
    );
    
    // 创建设置子菜单项
    menu_item_t* time_setting = MENU_ITEM_TEXT("Time", "Time Setting", 12);
    menu_item_t* date_setting = MENU_ITEM_TEXT("Date", "Date Setting", 12);
    menu_item_t* display_setting = MENU_ITEM_TEXT("Display", "Display Setting", 15);
    
    // 设置回调函数
    menu_item_set_callbacks(time_setting, on_time_setting_select, NULL, NULL, NULL);
    menu_item_set_callbacks(date_setting, on_date_setting_select, NULL, NULL, NULL);
    menu_item_set_callbacks(display_setting, on_display_setting_select, NULL, NULL, NULL);
    
    // 添加子菜单项
    menu_add_child(settings_menu, time_setting);
    menu_add_child(settings_menu, date_setting);
    menu_add_child(settings_menu, display_setting);
    
    // 将设置菜单添加到父菜单
    menu_add_child(parent, settings_menu);
    
    return settings_menu;
}
```

## 创建自定义菜单页面

### 1. 创建头文件

**在 `User/ui/Inc/custom_page.h` 中：**

```c
#ifndef __CUSTOM_PAGE_H
#define __CUSTOM_PAGE_H

#include "stm32f10x.h"
#include "FreeRTOS.h"
#include "unified_menu.h"
#include "oled_print.h"

// 自定义页面数据结构
typedef struct {
    int value;
    uint8_t status;
    uint8_t progress;
    char message[16];
} custom_page_data_t;

// 函数声明
menu_item_t* custom_page_init(void);
void draw_custom_page(void* context);
void on_custom_key(menu_item_t* item, uint8_t key_event);

#endif // __CUSTOM_PAGE_H
```

### 2. 创建实现文件

**在 `User/ui/Src/custom_page.c` 中：**

```c
#include "custom_page.h"
#include <string.h>

// 全局数据实例
static custom_page_data_t g_custom_data = {
    .value = 42,
    .status = 1,
    .progress = 80,
    .message = "Custom Page"
};

menu_item_t* custom_page_init(void)
{
    // 创建自定义菜单项
    menu_item_t* custom_menu = MENU_ITEM_CUSTOM(
        "Custom Page", 
        draw_custom_page, 
        &g_custom_data
    );
    
    // 设置回调函数
    menu_item_set_callbacks(custom_menu, 
                          on_custom_enter, 
                          on_custom_exit, 
                          NULL, 
                          on_custom_key);
    
    return custom_menu;
}

void draw_custom_page(void* context)
{
    custom_page_data_t* data = (custom_page_data_t*)context;
    if (data == NULL) return;
    
    // 清屏
    OLED_Clear();
    
    // 绘制标题
    OLED_Printf_Line(0, "%s", data->message);
    
    // 绘制数值
    OLED_Printf_Line(2, "Value: %d", data->value);
    
    // 绘制状态
    OLED_Printf_Line(3, "Status: %s", data->status ? "ON" : "OFF");
    
    // 绘制进度条
    OLED_Printf_Line(4, "Progress:");
    for (int i = 0; i < data->progress / 5; i++) {
        OLED_Printf(0 + i, 5, "=");
    }
    
    // 刷新显示
    OLED_Refresh();
}

void on_custom_enter(menu_item_t* item)
{
    printf("Enter custom page\r\n");
    // 页面进入时的初始化操作
}

void on_custom_exit(menu_item_t* item)
{
    printf("Exit custom page\r\n");
    // 页面退出时的清理操作
}

void on_custom_key(menu_item_t* item, uint8_t key_event)
{
    custom_page_data_t* data = (custom_page_data_t*)item->content.custom.draw_context;
    
    switch (key_event) {
        case MENU_EVENT_KEY_UP:
            data->value++;
            printf("Value increased to %d\r\n", data->value);
            break;
            
        case MENU_EVENT_KEY_DOWN:
            data->value--;
            printf("Value decreased to %d\r\n", data->value);
            break;
            
        case MENU_EVENT_KEY_ENTER:
            data->status = !data->status;
            printf("Status toggled to %s\r\n", data->status ? "ON" : "OFF");
            break;
            
        case MENU_EVENT_KEY_SELECT:
            menu_back_to_parent();
            printf("Return to parent menu\r\n");
            break;
    }
    
    // 触发显示刷新
    g_menu_sys.need_refresh = 1;
}
```

### 3. 在菜单系统中使用

```c
// 在主菜单创建函数中
void create_menu_system(void)
{
    // 创建根菜单
    menu_item_t* main_menu = main_menu_init();
    
    // 创建子菜单
    create_clock_menu(main_menu);
    create_settings_menu(main_menu);
    
    // 添加自定义页面
    menu_item_t* custom_page = custom_page_init();
    menu_add_child(main_menu, custom_page);
    
    // 设置布局
    g_menu_sys.layout = (menu_layout_config_t)LAYOUT_HORIZONTAL_MAIN();
}
```

## 项目集成指南

### 1. 修改主程序文件

**在 `User/main.c` 中：**

```c
#include "unified_menu.h"
#include "main_menu.h"  // 包含主菜单初始化函数

// 删除原有的显示队列相关代码（如果存在）

int main(void)
{
    // 系统初始化
    TIM2_Delay_Init();
    debug_init();
    OLED_Init();
    Key_Init();
    Beep_Init();
    
    printf("System init OK\r\n");
    
    // 初始化菜单系统
    if (menu_system_init() != 0) {
        printf("Menu system initialization failed\r\n");
        return -1;
    }
    
    // 创建菜单结构
    create_menu_system();
    
    // 创建菜单任务
    xTaskCreate(menu_task, "MenuTask", 512, NULL, 3, NULL);
    xTaskCreate(menu_key_task, "KeyTask", 128, NULL, 4, NULL);
    
    // 启动调度器
    vTaskStartScheduler();
    
    return 0;
}

// 删除原有的任务函数，使用框架提供的任务
```

### 2. 添加到编译系统

**在Keil中添加新文件：**

1. 右键点击项目 → "Add Files to Group..."
2. 添加新创建的源文件到对应的组
3. 在项目选项中添加头文件路径：`User/ui/Inc` 和 `User/icons`

### 3. 配置内存管理

**确保FreeRTOS有足够的堆空间：**

```c
// 在 FreeRTOSConfig.h 中
#define configTOTAL_HEAP_SIZE                    ( ( size_t ) ( 3 * 1024 ) )  // 3KB 堆空间
```

## API参考

### 核心API

| 函数名 | 描述 | 使用示例 |
|--------|------|----------|
| `menu_system_init()` | 初始化菜单系统 | `menu_system_init();` |
| `menu_item_create()` | 创建菜单项 | `menu_item_create("Name", type, content);` |
| `menu_add_child()` | 添加子菜单项 | `menu_add_child(parent, child);` |
| `menu_item_set_callbacks()` | 设置回调函数 | `menu_item_set_callbacks(item, enter, exit, select, key);` |
| `menu_enter()` | 进入指定菜单 | `menu_enter(menu);` |
| `menu_back_to_parent()` | 返回父菜单 | `menu_back_to_parent();` |
| `menu_select_next()` | 选择下一个菜单项 | `menu_select_next();` |
| `menu_select_previous()` | 选择上一个菜单项 | `menu_select_previous();` |
| `menu_enter_selected()` | 进入选中的菜单项 | `menu_enter_selected();` |
| `menu_refresh_display()` | 刷新菜单显示 | `menu_refresh_display();` |

### 便利宏

| 宏名 | 描述 | 使用示例 |
|------|------|----------|
| `MENU_ITEM_ICON()` | 创建图标菜单项 | `MENU_ITEM_ICON("Clock", icon, 32, 32)` |
| `MENU_ITEM_TEXT()` | 创建文本菜单项 | `MENU_ITEM_TEXT("Time", "Time Setting", 12)` |
| `MENU_ITEM_CUSTOM()` | 创建自定义菜单项 | `MENU_ITEM_CUSTOM("Custom", draw_func, context)` |
| `LAYOUT_HORIZONTAL_MAIN()` | 横向主菜单布局预设 | `g_menu_sys.layout = LAYOUT_HORIZONTAL_MAIN();` |
| `LAYOUT_VERTICAL_TEST()` | 竖向测试菜单布局预设 | `g_menu_sys.layout = LAYOUT_VERTICAL_TEST();` |

### 事件类型

| 事件类型 | 描述 | 对应按键 |
|----------|------|----------|
| `MENU_EVENT_KEY_UP` | 向上/左键 | KEY0 |
| `MENU_EVENT_KEY_DOWN` | 向下/右键 | KEY1 |
| `MENU_EVENT_KEY_SELECT` | 选择/返回键 | KEY2 |
| `MENU_EVENT_KEY_ENTER` | 确认/进入键 | KEY3 |
| `MENU_EVENT_REFRESH` | 刷新事件 | - |
| `MENU_EVENT_ALARM` | 闹钟事件 | - |

## 完整示例

### 示例1：创建一个完整的多级菜单系统

**项目结构：**
```
User/
├── ui/
│   ├── Inc/
│   │   ├── unified_menu.h
│   │   ├── main_menu.h
│   │   ├── clock_menu.h
│   │   ├── alarm_menu.h
│   │   └── settings_menu.h
│   └── Src/
│       ├── unified_menu.c
│       ├── main_menu.c
│       ├── clock_menu.c
│       ├── alarm_menu.c
│       └── settings_menu.c
└── icons/
    ├── icon_clock.h
    ├── icon_alarm.h
    └── icon_settings.h
```

**主菜单实现 (`main_menu.c`)：**
```c
#include "main_menu.h"
#include "clock_menu.h"
#include "alarm_menu.h"
#include "settings_menu.h"

menu_item_t* create_main_menu(void)
{
    // 创建主菜单
    menu_item_t* main_menu = menu_item_create(
        "Main Menu",
        MENU_TYPE_HORIZONTAL_ICON,
        (menu_content_t){0}
    );
    
    // 添加子菜单
    create_clock_menu(main_menu);
    create_alarm_menu(main_menu);
    create_settings_menu(main_menu);
    
    return main_menu;
}

void create_menu_system(void)
{
    // 创建根菜单
    menu_item_t* main_menu = create_main_menu();
    
    // 设置为根菜单
    g_menu_sys.root_menu = main_menu;
    g_menu_sys.current_menu = main_menu;
    
    // 设置布局
    g_menu_sys.layout = (menu_layout_config_t)LAYOUT_HORIZONTAL_MAIN();
}
```

**时钟菜单实现 (`clock_menu.c`)：**
```c
#include "clock_menu.h"
#include "unified_menu.h"
#include "../icons/icon_clock.h"

menu_item_t* create_clock_menu(menu_item_t* parent)
{
    menu_item_t* clock_menu = MENU_ITEM_ICON(
        "Clock", 
        icon_clock, 
        ICON_CLOCK_WIDTH, 
        ICON_CLOCK_HEIGHT
    );
    
    menu_item_set_callbacks(clock_menu, on_clock_enter, NULL, NULL, NULL);
    menu_add_child(parent, clock_menu);
    
    return clock_menu;
}

void on_clock_enter(menu_item_t* item)
{
    // 创建时钟显示页面
    menu_item_t* clock_page = menu_item_create(
        "Clock Display",
        MENU_TYPE_CUSTOM,
        (menu_content_t){
            .custom = {
                .draw_function = draw_clock_display,
                .draw_context = NULL
            }
        }
    );
    
    menu_item_set_callbacks(clock_page, NULL, NULL, NULL, on_clock_key);
    menu_enter(clock_page);
}

void draw_clock_display(void* context)
{
    // 获取当前时间
    MyRTC_ReadTime();
    
    OLED_Clear();
    OLED_Printf_Line(0, "Current Time");
    OLED_Printf_Line_32(2, " %02d:%02d:%02d", 
                       RTC_data.hours, RTC_data.minutes, RTC_data.seconds);
    OLED_Printf_Line(4, "%02d/%02d/%04d", 
                       RTC_data.day, RTC_data.mon, RTC_data.year);
    OLED_Refresh();
}

void on_clock_key(menu_item_t* item, uint8_t key_event)
{
    if (key_event == MENU_EVENT_KEY_SELECT) {
        menu_back_to_parent();
    }
}
```

### 示例2：创建一个数据设置页面

**头文件 (`data_setting.h`)：**
```c
#ifndef __DATA_SETTING_H
#define __DATA_SETTING_H

#include "stm32f10x.h"
#include "unified_menu.h"

typedef struct {
    int temperature;
    int humidity;
    int brightness;
    uint8_t edit_index;  // 当前编辑的项目索引
} data_setting_t;

menu_item_t* data_setting_init(void);

#endif // __DATA_SETTING_H
```

**实现文件 (`data_setting.c`)：**
```c
#include "data_setting.h"
#include "oled_print.h"

static data_setting_t g_data_setting = {
    .temperature = 25,
    .humidity = 60,
    .brightness = 80,
    .edit_index = 0
};

menu_item_t* data_setting_init(void)
{
    menu_item_t* setting_menu = menu_item_create(
        "Data Setting",
        MENU_TYPE_CUSTOM,
        (menu_content_t){
            .custom = {
                .draw_function = draw_data_setting,
                .draw_context = &g_data_setting
            }
        }
    );
    
    menu_item_set_callbacks(setting_menu, NULL, NULL, NULL, on_data_setting_key);
    return setting_menu;
}

void draw_data_setting(void* context)
{
    data_setting_t* data = (data_setting_t*)context;
    
    OLED_Clear();
    OLED_Printf_Line(0, "Data Setting");
    
    // 显示各项数据，当前编辑项用特殊标记
    OLED_Printf_Line(2, "%s Temperature: %d°C", 
                   (data->edit_index == 0) ? ">" : " ", data->temperature);
    OLED_Printf_Line(3, "%s Humidity: %d%%", 
                   (data->edit_index == 1) ? ">" : " ", data->humidity);
    OLED_Printf_Line(4, "%s Brightness: %d", 
                   (data->edit_index == 2) ? ">" : " ", data->brightness);
    
    OLED_Refresh();
}

void on_data_setting_key(menu_item_t* item, uint8_t key_event)
{
    data_setting_t* data = (data_setting_t*)item->content.custom.draw_context;
    
    switch (key_event) {
        case MENU_EVENT_KEY_UP:
            // 切换编辑项目
            if (data->edit_index > 0) data->edit_index--;
            break;
            
        case MENU_EVENT_KEY_DOWN:
            // 切换编辑项目
            if (data->edit_index < 2) data->edit_index++;
            break;
            
        case MENU_EVENT_KEY_ENTER:
            // 增加当前编辑项的值
            switch (data->edit_index) {
                case 0: if (data->temperature < 50) data->temperature++; break;
                case 1: if (data->humidity < 100) data->humidity++; break;
                case 2: if (data->brightness < 100) data->brightness++; break;
            }
            break;
            
        case MENU_EVENT_KEY_SELECT:
            // 返回
            menu_back_to_parent();
            break;
    }
    
    g_menu_sys.need_refresh = 1;
}
```

## 注意事项

### 1. 内存管理
- 菜单项使用动态内存分配，确保系统有足够的堆空间
- 对于17K内存的单片机，建议：
  - FreeRTOS堆大小设置为3KB-4KB
  - 菜单层级不超过3-4层
  - 每层菜单项不超过5-6个

### 2. 线程安全
- 显示函数使用互斥量保护，确保多任务环境下的安全访问
- 在自定义绘制函数中避免长时间阻塞

### 3. 按键处理
- 系统内置按键去抖机制，默认去抖时间为500ms
- 可以通过修改 `g_menu_sys.key_debounce_time` 调整

### 4. 刷新频率
- 显示刷新频率为100ms，可根据需要调整
- 在自定义页面中可通过设置 `g_menu_sys.need_refresh = 1` 触发刷新

### 5. 任务优先级
- 建议按键任务优先级高于菜单任务，确保及时响应
- 推荐优先级：按键任务(4) > 菜单任务(3) > 其他任务(1-2)

### 6. 编译配置
- 确保在编译器中包含所有新创建的文件
- 添加正确的头文件搜索路径

## 故障排除

### 常见问题

1. **菜单不显示**
   - 检查菜单系统是否正确初始化：`menu_system_init()`
   - 确认OLED显示是否正常工作
   - 检查是否正确设置了当前菜单：`g_menu_sys.current_menu`
   - 验证是否正确创建了菜单任务

2. **按键无响应**
   - 检查按键任务是否创建并运行：`menu_key_task()`
   - 确认按键硬件驱动是否正常：`Key_Init()`
   - 检查事件队列是否正确创建
   - 验证按键去抖时间是否合适

3. **显示异常**
   - 检查布局配置是否正确：`g_menu_sys.layout`
   - 确认菜单项位置是否在显示范围内
   - 检查是否正确刷新显示：`g_menu_sys.need_refresh`
   - 验证OLED驱动是否正常

4. **内存不足**
   - 检查FreeRTOS堆大小配置
   - 考虑使用静态分配代替动态分配
   - 优化菜单项数量和层级深度
   - 检查是否有内存泄漏

5. **编译错误**
   - 确认所有新文件都已添加到项目
   - 检查头文件路径是否正确
   - 验证函数声明和定义是否匹配
   - 检查是否有重复定义

### 调试技巧

1. **启用调试输出**
```c
// 在菜单回调中添加调试信息
void on_menu_enter(menu_item_t* item)
{
    printf("Enter menu: %s\r\n", item->name);
}
```

2. **检查内存使用**
```c
// 在FreeRTOS中启用堆统计
#include "task.h"
void print_heap_info(void)
{
    printf("Free heap: %d bytes\r\n", xPortGetFreeHeapSize());
}
```

3. **监控事件队列**
```c
// 在menu_process_event中添加事件日志
int8_t menu_process_event(menu_event_t *event)
{
    printf("Processing event: type=%d, timestamp=%d\r\n", 
           event->type, event->timestamp);
    // ... 原有处理逻辑
}
```

通过以上详细指南，您应该能够成功地将统一菜单框架集成到您的项目中，并创建出功能丰富的用户界面。如果遇到特定的问题，请参考相应的章节或查看源代码实现。